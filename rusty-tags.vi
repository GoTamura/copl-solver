!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/3fdf28bc/
Annot	/home/go/Documents/Rust/copl-solver/src/main.rs	/^impl<T> Annot<T> {$/;"	c
Annot	/home/go/Documents/Rust/copl-solver/src/main.rs	/^struct Annot<T> {$/;"	s
Eof	/home/go/Documents/Rust/copl-solver/src/main.rs	/^    Eof,$/;"	e	enum:LexErrorKind
InvalidChar	/home/go/Documents/Rust/copl-solver/src/main.rs	/^    InvalidChar(char),$/;"	e	enum:LexErrorKind
LexError	/home/go/Documents/Rust/copl-solver/src/main.rs	/^impl LexError {$/;"	c
LexError	/home/go/Documents/Rust/copl-solver/src/main.rs	/^type LexError = Annot<LexErrorKind>;$/;"	t
LexErrorKind	/home/go/Documents/Rust/copl-solver/src/main.rs	/^enum LexErrorKind {$/;"	g
Loc	/home/go/Documents/Rust/copl-solver/src/main.rs	/^impl Loc {$/;"	c
Loc	/home/go/Documents/Rust/copl-solver/src/main.rs	/^struct Loc(usize, usize);$/;"	s
Number	/home/go/Documents/Rust/copl-solver/src/main.rs	/^    Number(u64),$/;"	e	enum:TokenKind
Plus	/home/go/Documents/Rust/copl-solver/src/main.rs	/^    Plus,$/;"	e	enum:TokenKind
Token	/home/go/Documents/Rust/copl-solver/src/main.rs	/^impl Token {$/;"	c
Token	/home/go/Documents/Rust/copl-solver/src/main.rs	/^type Token = Annot<TokenKind>;$/;"	t
TokenKind	/home/go/Documents/Rust/copl-solver/src/main.rs	/^enum TokenKind {$/;"	g
consume_byte	/home/go/Documents/Rust/copl-solver/src/main.rs	/^fn consume_byte(input: &[u8], pos: usize, b: u8) -> Result<(u8, usize), LexError> {$/;"	f
eof	/home/go/Documents/Rust/copl-solver/src/main.rs	/^    fn eof(loc: Loc) -> Self {$/;"	P	implementation:LexError
invalid_char	/home/go/Documents/Rust/copl-solver/src/main.rs	/^    fn invalid_char(c: char, loc: Loc) -> Self {$/;"	P	implementation:LexError
lex	/home/go/Documents/Rust/copl-solver/src/main.rs	/^fn lex(input: &str) -> Result<Vec<Token>, LexError> {$/;"	f
lex_a_token	/home/go/Documents/Rust/copl-solver/src/main.rs	/^    macro_rules! lex_a_token {$/;"	M	function:lex
lex_number	/home/go/Documents/Rust/copl-solver/src/main.rs	/^fn lex_number(input: &[u8], pos: usize) -> Result<(Token, usize), LexError> {$/;"	f
lex_plus	/home/go/Documents/Rust/copl-solver/src/main.rs	/^fn lex_plus(input: &[u8], start: usize) -> Result<(Token, usize), LexError> {$/;"	f
loc	/home/go/Documents/Rust/copl-solver/src/main.rs	/^    loc: Loc,$/;"	m	struct:Annot
main	/home/go/Documents/Rust/copl-solver/src/main.rs	/^fn main() {$/;"	f
merge	/home/go/Documents/Rust/copl-solver/src/main.rs	/^    fn merge(&self, other: &Loc) -> Loc {$/;"	P	implementation:Loc
new	/home/go/Documents/Rust/copl-solver/src/main.rs	/^    fn new(value: T, loc: Loc) -> Self {$/;"	P	implementation:Annot
number	/home/go/Documents/Rust/copl-solver/src/main.rs	/^    fn number(n: u64, loc: Loc) -> Self {$/;"	P	implementation:Token
plus	/home/go/Documents/Rust/copl-solver/src/main.rs	/^    fn plus(loc: Loc) -> Self {$/;"	P	implementation:Token
recognize_many	/home/go/Documents/Rust/copl-solver/src/main.rs	/^fn recognize_many(input: &[u8], mut pos: usize, mut f: impl FnMut(u8) -> bool) -> usize {$/;"	f
skip_spaces	/home/go/Documents/Rust/copl-solver/src/main.rs	/^fn skip_spaces(input: &[u8], pos: usize) -> Result<((), usize), LexError> {$/;"	f
test_lexer_plus_number	/home/go/Documents/Rust/copl-solver/src/main.rs	/^fn test_lexer_plus_number() {$/;"	f
value	/home/go/Documents/Rust/copl-solver/src/main.rs	/^    value: T,$/;"	m	struct:Annot
